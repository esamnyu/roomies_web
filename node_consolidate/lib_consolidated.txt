// Consolidated 12 files from the "lib" folder
// This file contains all code files within the "lib" folder and its subfolders.

// Directory: lib, File: auth.ts
// File Type: ts
```typescript
// src/lib/auth.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient, type CookieOptions } from '@supabase/ssr';
import { cookies } from 'next/headers';
// Assuming supabaseAdmin is the client with SERVICE_ROLE_KEY from your lib/supabase.ts
import { supabase as supabaseAdmin, supabaseClient } from '@/lib/supabase';

// --- Define User Type (align with your DB and Supabase Auth user) ---
// You might already have a better place for this, like src/types/index.ts
interface UserProfile {
  id: string;
  name: string | null;
  email: string | null;
  avatar: string | null;
  // Add other fields from your 'User' table if needed
}

// --- Error Classes (Keep as they are useful) ---
export class AuthenticationError extends Error {
  status: number;
  constructor(message: string, status: number = 401) {
    super(message);
    this.name = 'AuthenticationError';
    this.status = status;
  }
}

export class AuthorizationError extends Error {
  status: number;
  constructor(message: string, status: number = 403) {
    super(message);
    this.name = 'AuthorizationError';
    this.status = status;
  }
}

// --- Helper to create Supabase client within Route Handlers or Server Components ---
// Consistent with the pattern used in your API routes
const createSupabaseServerClient = async () => {
  const cookieStore = await cookies(); // Cannot be called at top level
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) { return cookieStore.get(name)?.value; },
        set(name: string, value: string, options: CookieOptions) { try { cookieStore.set({ name, value, ...options }); } catch (error) { console.error("Error setting cookie:", name, error); } },
        remove(name: string, options: CookieOptions) { try { cookieStore.set({ name, value: '', ...options }); } catch (error) { console.error("Error removing cookie:", name, error); } },
      },
    }
  );
};


/**
 * Get the currently authenticated Supabase user session data.
 * Use this in Route Handlers or Server Components where `cookies()` is available.
 */
export async function getCurrentSessionUser() {
  // Use dynamic client creation within the function
  const supabase = await createSupabaseServerClient();
  const { data: { user }, error } = await supabase.auth.getUser();

  if (error) {
    console.error("Error fetching Supabase user:", error.message);
    throw new AuthenticationError('Failed to retrieve user session');
  }
  if (!user) {
    throw new AuthenticationError('Unauthorized - no active session found');
  }

  // Optional: Fetch profile details from your 'User' table if needed beyond auth user
  // const userProfile = await getUserProfile(user.id); // See getUserProfile below

  return user; // Returns Supabase Auth User object
  // return { ...user, profile: userProfile }; // Example if merging with profile
}

/**
 * Get the user's profile from the public 'User' table.
 * Uses the admin client to bypass RLS if needed, or SSR client if RLS allows.
 * Choose ONE client based on your RLS setup.
 */
export async function getUserProfile(userId: string): Promise<UserProfile | null> {
  // Option 1: Use SSR Client (Relies on RLS allowing user to read their own profile)
  // const supabase = createSupabaseServerClient();
  // const { data, error } = await supabase
  //   .from('User')
  //   .select('id, name, email, avatar')
  //   .eq('id', userId)
  //   .single();

  // Option 2: Use Admin Client (Bypasses RLS - use if RLS restricts profile reads)
   const { data, error } = await supabaseAdmin // Use admin client
     .from('User')
     .select('id, name, email, avatar') // Adjust fields as needed
     .eq('id', userId)
     .single();

  if (error) {
    console.error(`Error fetching user profile for ${userId}:`, error.message);
    // Don't throw Auth error here, just indicate profile fetch failed
    return null;
  }
  if (!data) {
      console.warn(`No user profile found in 'User' table for id ${userId}`);
      return null;
  }

  return data as UserProfile;
}

/**
 * Get the user's database profile entry using their Auth ID.
 * Combines fetching session and profile.
 * Use this in Route Handlers or Server Components.
 */
export async function getCurrentUserWithProfile(): Promise<{ auth: any; profile: UserProfile }> {
  const authUser = await getCurrentSessionUser(); // Get Supabase Auth User first

  // Fetch profile from your 'User' table
  const profile = await getUserProfile(authUser.id);

  if (!profile) {
    // Decide how to handle missing profile: throw error or return with null profile?
    // Throwing might be safer to ensure profile exists where needed.
    throw new Error(`User profile not found in database for authenticated user ${authUser.id}`);
  }

  return { auth: authUser, profile };
}

/**
 * Check if a user is an admin of the specified household.
 * Uses the Admin client to bypass RLS for checking HouseholdUser table reliably.
 */
export async function verifyHouseholdAdmin(userId: string, householdId: string): Promise<boolean> {
  // Use admin client for potentially restricted HouseholdUser table access
  const { data: membership, error } = await supabaseAdmin
    .from('HouseholdUser')
    .select('role')
    .eq('userId', userId)
    .eq('householdId', householdId)
    .single();

  if (error) {
    // Distinguish between "not found" and other errors
    if (error.code === 'PGRST116') { // code for "No rows returned"
      throw new AuthorizationError('You are not a member of this household');
    }
    console.error("Error verifying household admin:", error.message);
    throw new Error('Failed to verify household permissions');
  }

  if (!membership) { // Should be caught by PGRST116, but safety check
      throw new AuthorizationError('You are not a member of this household');
  }

  if (membership.role !== 'ADMIN') {
    throw new AuthorizationError('Only household admins can perform this action');
  }

  return true;
}

/**
 * Higher-order function for creating authenticated API handlers using Supabase Auth.
 */
export function withAuth<T = any>(
  // Handler expects the Supabase Auth User object and optionally the profile
  handler: (request: NextRequest, context: { params?: any }, session: { auth: any, profile: UserProfile | null }) => Promise<NextResponse<T>> | NextResponse<T>
) {
  return async (request: NextRequest, context: { params?: any }): Promise<NextResponse<T>> => {
    try {
      const authUser = await getCurrentSessionUser(); // Checks session validity
      const userProfile = await getUserProfile(authUser.id); // Fetch profile separately

      // Pass both auth user and profile (which might be null)
      return await handler(request, context, { auth: authUser, profile: userProfile });

    } catch (error: any) {
      console.error('[withAuth Error]:', error.message);
      if (error instanceof AuthenticationError || error instanceof AuthorizationError) {
        return NextResponse.json({ error: error.message }, { status: error.status }) as NextResponse<T>;
      }
      // Handle Supabase Auth errors specifically if needed
      // if (error.name === 'AuthApiError') { ... }

      return NextResponse.json(
        { error: 'Internal server error during authentication check' },
        { status: 500 }
      ) as NextResponse<T>;
    }
  };
}


/**
 * Higher-order function for creating handlers that require household admin permissions.
 * Assumes householdId is available, typically from URL parameters (context.params).
 */
export function withHouseholdAdmin<T = any>(
  // Handler expects Auth User, User Profile, and verified householdId
  handler: (request: NextRequest, context: { params?: any }, session: { auth: any, profile: UserProfile }, householdId: string) => Promise<NextResponse<T>> | NextResponse<T>
) {
  return async (request: NextRequest, context: { params?: any }): Promise<NextResponse<T>> => {
    try {
      const { auth: authUser, profile } = await getCurrentUserWithProfile(); // Ensures user is logged in and profile exists

      // --- Get householdId ---
      // Option 1: From URL path parameter (e.g., /api/households/[id]/...)
      const householdIdFromParams = context.params?.id || context.params?.householdId;

      // Option 2: From query string (e.g., /api/some-route?householdId=...)
      const householdIdFromQuery = request.nextUrl.searchParams.get('householdId');

      // Choose the source based on your API structure, prioritizing path params
      const householdId = householdIdFromParams || householdIdFromQuery;

      if (!householdId) {
        return NextResponse.json(
          { error: 'Missing required householdId parameter in URL path or query string' },
          { status: 400 }
        ) as NextResponse<T>;
      }
      // --- End Get householdId ---


      // Verify the user is an admin for this specific household
      await verifyHouseholdAdmin(authUser.id, householdId);

      // Call the actual handler, passing the authenticated user, profile, and verified householdId
      return await handler(request, context, { auth: authUser, profile }, householdId);

    } catch (error: any) {
      console.error('[withHouseholdAdmin Error]:', error.message);
      if (error instanceof AuthenticationError || error instanceof AuthorizationError) {
        return NextResponse.json({ error: error.message }, { status: error.status }) as NextResponse<T>;
      }
       // Handle Supabase Auth errors specifically if needed

      return NextResponse.json(
        { error: 'Internal server error during admin authorization check' },
        { status: 500 }
      ) as NextResponse<T>;
    }
  };
}


/**
 * Ensures a user profile exists in the public 'User' table after Supabase Auth sign-up/sign-in.
 * Should typically be called via a trigger/function in Supabase DB for robustness,
 * but can be called from backend code if necessary (e.g., after social login).
 *
 * @param authUser - The Supabase Auth User object (must contain id and email).
 * @param profileData - Optional additional data (like name, avatar) to insert/update.
 * @returns The user ID from the 'User' table.
 */
export async function ensureUserProfileExists(
    authUser: { id: string; email?: string | null; user_metadata?: { name?: string, avatar_url?: string } },
    profileData: Partial<UserProfile> = {}
): Promise<string> {
    if (!authUser || !authUser.id) {
        throw new Error('Valid Supabase Auth User object with ID is required.');
    }

    const userId = authUser.id;
    const userEmail = authUser.email || null;
    // Extract name/avatar from user_metadata if available (common with social auth)
    const userName = profileData.name ?? authUser.user_metadata?.name ?? userEmail?.split('@')[0] ?? 'New User';
    const userAvatar = profileData.avatar ?? authUser.user_metadata?.avatar_url ?? null;

    // Use Admin Client to perform upsert, bypassing RLS if necessary
    const { data, error } = await supabaseAdmin
        .from('User')
        .upsert(
            {
                id: userId, // Match based on the Auth user ID
                email: userEmail,
                name: userName,
                avatar: userAvatar,
                // Add other default fields for your User table if needed on creation
                // password: 'SUPABASE_AUTH' // Can be set here or via default value in DB
                updatedAt: new Date().toISOString(), // Explicitly set update timestamp
            },
            {
                onConflict: 'id', // Specify the conflict target
                // ignoreDuplicates: false // Default is false, ensures update happens if exists
            }
        )
        .select('id') // Select only the id after upsert
        .single();

    if (error) {
        console.error(`Error ensuring user profile exists for ${userId}:`, error.message);
        throw new Error('Failed to create or update user profile record');
    }
    if (!data) {
         console.error(`Upsert operation for user profile ${userId} did not return data.`);
         throw new Error('Failed to create or update user profile record');
    }

    console.log(`User profile ensured for ID: ${data.id}`);
    return data.id; // Return the user ID from the User table
}
```

// Directory: lib, File: chat.ts
// File Type: ts
```typescript
// src/lib/chat.ts
import { supabaseClient } from './supabase';
import { generateUUID } from '@/lib/utils';

// Types
export interface Message {
  id: string;
  householdId: string;
  senderId: string;
  content: string;
  contentType?: string;
  createdAt: string;
  updatedAt: string;
  sender?: {
    id: string;
    name: string;
    avatar?: string;
  };
  readReceipts?: ReadReceipt[];
}

export interface ReadReceipt {
  id: string;
  messageId: string;
  userId: string;
  readAt: string;
}

// Get messages for a household
export async function getHouseholdMessages(householdId: string): Promise<Message[]> {
  console.log(`Fetching messages for household: ${householdId}`);
  
  try {
    const { data, error } = await supabaseClient
      .from('Message')
      .select(`
        *,
        sender:senderId(id, name, avatar),
        readReceipts:MessageReadReceipt(id, userId, readAt)
      `)
      .eq('householdId', householdId)
      .order('createdAt', { ascending: true });

    if (error) {
      console.error('Error fetching messages:', error);
      return [];
    }

    console.log(`Retrieved ${data?.length || 0} messages for household ${householdId}`);
    return data || [];
  } catch (err) {
    console.error('Unexpected error fetching messages:', err);
    return [];
  }
}

// Send a message to a household
export async function sendMessage(householdId: string, senderId: string, content: string): Promise<Message | null> {
  // Generate a UUID for the message ID
  const messageId = generateUUID();
  const now = new Date().toISOString();
  
  console.log(`Sending message with ID: ${messageId} to household: ${householdId}`);
  
  try {
    const { data, error } = await supabaseClient
      .from('Message')
      .insert([
        {
          id: messageId,
          householdId,
          senderId,
          content,
          contentType: 'TEXT',
          createdAt: now,
          updatedAt: now
        }
      ])
      .select(`
        *,
        sender:senderId(id, name, avatar)
      `)
      .single();
  
    if (error) {
      console.error(`Error sending message to household ${householdId}:`, error);
      // Provide more detailed error information for debugging
      if (error.code === '42501') {
        console.error('Permission denied - check RLS policies');
      } else if (error.code === '23505') {
        console.error('Duplicate ID - UUID collision');
      } else if (error.code === '42P01') {
        console.error('Table does not exist');
      }
      return null;
    }
  
    console.log('Message sent successfully:', data);
    return data;
  } catch (err) {
    console.error('Unexpected error sending message:', err);
    return null;
  }
}

/**
 * Send a welcome message when a user joins a household
 */
export async function sendWelcomeMessage(householdId: string, userId: string, userName: string): Promise<Message | null> {
  const messageId = generateUUID();
  const now = new Date().toISOString();
  
  try {
    const { data, error } = await supabaseClient
      .from('Message')
      .insert([
        {
          id: messageId,
          householdId,
          senderId: userId, // System or admin user ID
          content: `üëã ${userName} has joined the household! Say hello!`,
          contentType: 'TEXT',
          createdAt: now,
          updatedAt: now
        }
      ])
      .select(`*, sender:senderId(id, name, avatar)`)
      .single();
  
    if (error) {
      console.error(`Error sending welcome message:`, error);
      return null;
    }
  
    return data;
  } catch (err) {
    console.error('Error sending welcome message:', err);
    return null;
  }
}

// Mark message as read
export async function markMessageAsRead(messageId: string, userId: string): Promise<ReadReceipt | null> {
  console.log(`Marking message ${messageId} as read by user ${userId}`);
  
  try {
    // Check if a read receipt already exists
    const { data: existingReceipt, error: receiptError } = await supabaseClient
      .from('MessageReadReceipt')
      .select('id, messageId, userId, readAt')
      .eq('messageId', messageId)
      .eq('userId', userId)
      .single();
    
    if (!receiptError && existingReceipt) {
      // Already marked as read
      console.log(`Message ${messageId} already marked as read`);
      return existingReceipt as ReadReceipt;
    }
    
    // Generate a UUID for the receipt
    const receiptId = generateUUID();
    
    // Create a new read receipt
    const { data, error } = await supabaseClient
      .from('MessageReadReceipt')
      .insert([
        {
          id: receiptId,
          messageId,
          userId,
          readAt: new Date().toISOString()
        }
      ])
      .select()
      .single();
    
    if (error) {
      console.error('Error marking message as read:', error);
      if (error.code === '42501') {
        console.error('Permission denied - check RLS policies');
      }
      return null;
    }
    
    console.log(`Successfully marked message ${messageId} as read`);
    return data as ReadReceipt;
  } catch (err) {
    console.error('Unexpected error marking message as read:', err);
    return null;
  }
}

// Get unread messages count for user in a household
export async function getUnreadMessagesCount(householdId: string, userId: string): Promise<number> {
  console.log(`Calculating unread messages for user ${userId} in household ${householdId}`);
  
  try {
    // Get all messages for the household
    const { data: messages, error: messagesError } = await supabaseClient
      .from('Message')
      .select('id')
      .eq('householdId', householdId)
      .neq('senderId', userId); // Exclude messages sent by the current user
    
    if (messagesError || !messages) {
      console.error('Error fetching messages for unread count:', messagesError);
      return 0;
    }
    
    if (messages.length === 0) {
      return 0;
    }
    
    // Get read receipts for these messages
    const messageIds = messages.map(msg => msg.id);
    const { data: receipts, error: receiptsError } = await supabaseClient
      .from('MessageReadReceipt')
      .select('messageId')
      .eq('userId', userId)
      .in('messageId', messageIds);
    
    if (receiptsError) {
      console.error('Error fetching read receipts:', receiptsError);
      return 0;
    }
    
    // Count unread messages
    const readMessageIds = receipts?.map(receipt => receipt.messageId) || [];
    const unreadCount = messages.filter(msg => !readMessageIds.includes(msg.id)).length;
    
    console.log(`User ${userId} has ${unreadCount} unread messages in household ${householdId}`);
    return unreadCount;
  } catch (err) {
    console.error('Unexpected error getting unread count:', err);
    return 0;
  }
}

export function subscribeToMessages(householdId: string, callback: (message: Message) => void) {
    console.log(`Setting up message subscription for household: ${householdId}`);
    
    try {
      // Use a unique channel name that includes the household ID
      const channel = supabaseClient
        .channel(`messages-${householdId}`)
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'Message',
            filter: `householdId=eq.${householdId}`
          },
          async (payload) => {
            console.log('Subscription received new message:', payload);
            
            // Fetch the complete message with sender information
            try {
              const { data, error } = await supabaseClient
                .from('Message')
                .select(`
                  *,
                  sender:senderId(id, name, avatar)
                `)
                .eq('id', payload.new.id)
                .single();
                
              if (!error && data) {
                console.log('Complete message data:', data);
                callback(data as Message);
              } else {
                // Log error but still use the payload data
                console.error('Error fetching complete message:', error);
                // Convert the payload to match the Message interface as closely as possible
                const simpleMessage: Message = {
                  id: payload.new.id,
                  householdId: payload.new.householdId,
                  senderId: payload.new.senderId,
                  content: payload.new.content,
                  contentType: payload.new.contentType || 'TEXT',
                  createdAt: payload.new.createdAt || new Date().toISOString(),
                  updatedAt: payload.new.updatedAt || new Date().toISOString()
                };
                callback(simpleMessage);
              }
            } catch (err) {
              console.error('Error in subscription callback:', err);
              // Still try to use the payload even if the fetch fails
              callback(payload.new as Message);
            }
          }
        )
        .subscribe((status) => {
          console.log(`Subscription status for household ${householdId}:`, status);
        });
    
      return () => {
        console.log(`Removing subscription for household: ${householdId}`);
        supabaseClient.removeChannel(channel);
      };
    } catch (error) {
      console.error('Error setting up message subscription:', error);
      // Return a no-op cleanup function
      return () => {};
    }
}
```

// Directory: lib, File: databaseReadiness.ts
// File Type: ts
```typescript
// src/lib/databaseReadiness.ts
import { supabaseClient } from './supabase';

/**
 * Check if the Message table is ready to use
 * @returns {Promise<boolean>} True if the table exists and is accessible
 */
export async function isMessageTableReady(): Promise<boolean> {
  try {
    console.log('Checking if Message table is ready...');
    
    // Get the current user session first to ensure authenticated
    const { data: { session } } = await supabaseClient.auth.getSession();
    if (!session) {
      console.error('No active session for database check');
      return false;
    }
    
    // Try to select a single record from the Message table
    const { data, error } = await supabaseClient
      .from('Message')
      .select('id')
      .limit(1);
    
    console.log('Message table check result:', { data, error });
    
    // If there's no error, the table exists and is accessible
    if (!error) {
      console.log('Message table is ready to use');
      return true;
    }
    
    // Log the specific error
    console.error('Message table not ready:', error.message, error.details, error.hint, error.code);
    return false;
  } catch (err) {
    console.error('Error checking Message table:', err);
    return false;
  }
}

/**
 * Check if all chat-related tables are ready to use
 * @returns {Promise<{ready: boolean, tables: Record<string, boolean>}>} Status of all tables
 */
export async function areAllChatTablesReady(): Promise<{ready: boolean, tables: Record<string, boolean>}> {
  try {
    console.log('Checking if all chat tables are ready...');
    
    // Get the current user's session
    const { data: { session } } = await supabaseClient.auth.getSession();
    if (!session) {
      console.error('No active session for database tables check');
      return {
        ready: false,
        tables: {
          message: false,
          messageReadReceipt: false
        }
      };
    }
    
    console.log('User session found:', session.user.id);
    
    // Check if Message table is ready
    const isMessageReady = await isMessageTableReady();
    
    // Check MessageReadReceipt table
    console.log('Checking if MessageReadReceipt table is ready...');
    const { data: receiptData, error: receiptError } = await supabaseClient
      .from('MessageReadReceipt')
      .select('id')
      .limit(1);
    
    console.log('MessageReadReceipt table check result:', { receiptData, receiptError });
    
    const isReceiptReady = !receiptError;
    if (isReceiptReady) {
      console.log('MessageReadReceipt table is ready to use');
    } else {
      console.error('MessageReadReceipt table not ready:', 
        receiptError?.message, 
        receiptError?.details, 
        receiptError?.hint,
        receiptError?.code
      );
    }
    
    // Overall readiness status
    const allReady = isMessageReady && isReceiptReady;
    
    console.log('Chat tables readiness summary:', {
      ready: allReady,
      message: isMessageReady,
      messageReadReceipt: isReceiptReady
    });
    
    return {
      ready: allReady,
      tables: {
        message: isMessageReady,
        messageReadReceipt: isReceiptReady
      }
    };
  } catch (err) {
    console.error('Error checking chat tables:', err);
    return {
      ready: false,
      tables: {
        message: false,
        messageReadReceipt: false
      }
    };
  }
}
```

// Directory: lib, File: email.ts
// File Type: ts
```typescript
// src/lib/email.ts - temporary version without SendGrid dependency

interface InvitationEmailParams {
  to: string;
  inviterName: string;
  householdName: string;
  invitationLink: string;
  role: string;
  message?: string;
  expirationDays?: number;
}

/**
 * Mock implementation that logs emails instead of sending them
 */
export async function sendInvitationEmail({
  to,
  inviterName,
  householdName,
  invitationLink,
  role,
  message,
  expirationDays = 7
}: InvitationEmailParams): Promise<boolean> {
  // Log what would have been sent
  console.log('=== MOCK EMAIL SERVICE ===');
  console.log(`Would send invitation email to: ${to}`);
  console.log(`From: ${inviterName}`);
  console.log(`Household: ${householdName}`);
  console.log(`Role: ${role}`);
  console.log(`Link: ${invitationLink}`);
  if (message) console.log(`Message: ${message}`);
  console.log(`Expires in: ${expirationDays} days`);
  console.log('=========================');
  
  // Return success since we're just mocking
  return true;
}
```

// Directory: lib, File: errorhandler.ts
// File Type: ts
```typescript
// src/lib/errorhandler.ts
import { NextResponse } from 'next/server';
import { AuthenticationError, AuthorizationError } from '@/lib/auth';
import { ValidationError, ResourceNotFoundError, ConflictError } from '@/lib/services/invitationService';

/**
 * Centralized API error handler for consistent error responses
 */
export function handleApiError(error: unknown) {
  console.error('API error:', error);
  
  // Return appropriate status code based on error type
  if (error instanceof ValidationError) {
    return NextResponse.json({ error: error.message }, { status: error.status });
  }
  
  if (error instanceof ResourceNotFoundError) {
    return NextResponse.json({ error: error.message }, { status: error.status });
  }
  
  if (error instanceof ConflictError) {
    return NextResponse.json({ 
      error: error.message,
      ...error.details
    }, { status: error.status });
  }
  
  if (error instanceof AuthenticationError) {
    return NextResponse.json({ error: error.message }, { status: error.status });
  }
  
  if (error instanceof AuthorizationError) {
    return NextResponse.json({ error: error.message }, { status: error.status });
  }
  
  // For unknown errors, return 500
  return NextResponse.json({ 
    error: 'Internal server error',
    message: error instanceof Error ? error.message : 'Unknown error'
  }, { status: 500 });
}
```

// Directory: lib, File: supabase-ssr.ts
// File Type: ts
```typescript
// src/lib/supabase-ssr.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { createClient } from '@supabase/supabase-js'
import { cookies } from 'next/headers'

export async function createServerSupabaseClient() {
  const cookieStore = await cookies()
  
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({ name, value, ...options })
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.set({ name, value: '', ...options })
        },
      },
    }
  )
}

// For client components
export function createBrowserSupabaseClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
      }
    }
  )
}
```

// Directory: lib, File: supabase.ts
// File Type: ts
```typescript
// src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js';

// Environment variables
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Check if we have the required environment variables
if (!supabaseUrl || !supabaseAnonKey) {
  console.error('Missing required Supabase environment variables');
}

// Client for browser usage (with anonymous key)
export const supabaseClient = createClient(
  supabaseUrl || '',
  supabaseAnonKey || '',
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    }
  }
);

// Admin client for server-side operations (with service role key)
export const supabase = supabaseServiceKey 
  ? createClient(
      supabaseUrl || '',
      supabaseServiceKey,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    )
  : supabaseClient; // Fall back to the client if no service key is provided
```

// Directory: lib, File: test-supabase.ts
// File Type: ts
```typescript
// src/lib/test-supabase.js
const { createClient } = require('@supabase/supabase-js');

// Get environment variables
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

// Check if environment variables are available
if (!supabaseUrl || !supabaseKey) {
  console.error('‚ùå Missing Supabase environment variables!');
  console.log('Make sure you have NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY in your .env file');
  process.exit(1);
}

// Initialize Supabase
const supabase = createClient(supabaseUrl, supabaseKey);

async function testSupabaseConnection() {
  try {
    console.log('Testing Supabase connection...');
    
    // Test a simple query - trying to access public schema information
    const { data, error } = await supabase
      .from('User')
      .select('count()', { count: 'exact' });
    
    if (error) {
      console.error('‚ùå Supabase query failed:', error.message);
      
      // Try a different approach - check if we can reach Supabase at all
      const { data: healthData, error: healthError } = await supabase.rpc('get_service_status');
      
      if (healthError) {
        console.error('‚ùå Could not connect to Supabase:', healthError.message);
      } else {
        console.log('‚úÖ Supabase is reachable, but the query failed. This might be due to:');
        console.log('  - The "User" table doesn\'t exist yet');
        console.log('  - Permissions issues (Row Level Security)');
        console.log('  - The table name is different from "User"');
      }
      
      return false;
    }
    
    console.log('‚úÖ Supabase connection successful!');
    console.log('Query result:', data);
    return true;
  } catch (err) {
    console.error('‚ùå Unexpected error testing Supabase connection:', err);
    return false;
  }
}

// Run the test with environment variables loaded from .env
require('dotenv').config();
testSupabaseConnection();
```

// Directory: lib, File: utils.ts
// File Type: ts
```typescript
// src/lib/utils.ts

/**
 * Generates a UUID v4 string
 * This can be used for creating unique IDs for database records
 * @returns {string} A UUID v4 string
 */
export function generateUUID(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  /**
   * Format a date for display
   * @param date Date to format
   * @param includeTime Whether to include the time
   * @returns Formatted date string
   */
  export function formatDate(date: Date | string, includeTime: boolean = false): string {
    const dateObj = typeof date === 'string' ? new Date(date) : date;
    
    if (includeTime) {
      return dateObj.toLocaleString();
    }
    
    return dateObj.toLocaleDateString();
  }
  
  /**
   * Truncate a string to a specific length and add ellipsis if needed
   * @param str String to truncate
   * @param length Maximum length
   * @returns Truncated string
   */
  export function truncate(str: string, length: number): string {
    if (str.length <= length) return str;
    return str.slice(0, length) + '...';
  }
  
  /**
   * Delay execution for a specified number of milliseconds
   * Useful for throttling or creating intentional delays
   * @param ms Milliseconds to delay
   * @returns Promise that resolves after the specified time
   */
  export function delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  /**
   * Check if a value is empty (null, undefined, empty string, or empty array)
   * @param value Value to check
   * @returns True if the value is empty
   */
  export function isEmpty(value: any): boolean {
    if (value === null || value === undefined) return true;
    if (typeof value === 'string') return value.trim() === '';
    if (Array.isArray(value)) return value.length === 0;
    if (typeof value === 'object') return Object.keys(value).length === 0;
    return false;
  }
```

// Directory: lib\services, File: expenseService.ts
// File Type: ts
```typescript
// lib/services/expenseService.ts
import { Expense, Payment } from '../../types'; // Adjust the path based on the relative location

// Fetch all expenses for a household
export async function fetchExpenses(householdId: string) {
  if (!householdId || householdId === 'undefined') {
    console.error('Invalid household ID provided to fetchExpenses');
    throw new Error('Valid household ID required');
  }

  const response = await fetch(`/api/expenses?householdId=${householdId}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include' // Include cookies for authentication
  });

  if (!response.ok) {
    throw new Error('Failed to fetch expenses');
  }

  return response.json();
}

// Get a single expense
export async function fetchExpense(expenseId: string) {
  if (!expenseId) {
    throw new Error('Expense ID required');
  }

  const response = await fetch(`/api/expenses/${expenseId}`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include' // Include cookies for authentication
  });

  if (!response.ok) {
    throw new Error('Failed to fetch expense');
  }

  return response.json();
}

// Create a new expense
export async function createExpense(expenseData: Omit<Expense, 'id'>) {
  const response = await fetch('/api/expenses', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(expenseData),
    credentials: 'include' // Include cookies for authentication
  });

  if (!response.ok) {
    throw new Error('Failed to create expense');
  }

  return response.json();
}

// Update an expense
export async function updateExpense(expenseId: string, expenseData: Partial<Expense>) {
  if (!expenseId) {
    throw new Error('Expense ID required');
  }

  const response = await fetch(`/api/expenses/${expenseId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(expenseData),
    credentials: 'include' // Include cookies for authentication
  });

  if (!response.ok) {
    throw new Error('Failed to update expense');
  }

  return response.json();
}

// Delete an expense
export async function deleteExpense(expenseId: string) {
  if (!expenseId) {
    throw new Error('Expense ID required');
  }

  const response = await fetch(`/api/expenses/${expenseId}`, {
    method: 'DELETE',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include' // Include cookies for authentication
  });

  if (!response.ok) {
    throw new Error('Failed to delete expense');
  }

  return response.json();
}

// Update payment status
export async function updatePaymentStatus(paymentId: string, status: 'PENDING' | 'COMPLETED' | 'DECLINED') {
  if (!paymentId) {
    throw new Error('Payment ID required');
  }

  const response = await fetch(`/api/payments/${paymentId}`, {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ status }),
    credentials: 'include' // Include cookies for authentication
  });

  if (!response.ok) {
    throw new Error('Failed to update payment status');
  }

  return response.json();
}

// Fetch household members
export async function fetchHouseholdMembers(householdId: string) {
  // Validate householdId to prevent undefined errors
  if (!householdId || householdId === 'undefined') {
    console.error('Invalid household ID provided to fetchHouseholdMembers');
    throw new Error('Valid household ID required');
  }

  console.log(`Fetching members for household ID: ${householdId}`);
  
  const response = await fetch(`/api/households/${householdId}/members`, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
    credentials: 'include' // Include cookies for authentication
  });

  if (!response.ok) {
    const status = response.status;
    console.error(`Failed to fetch household members - Status: ${status}`);
    throw new Error(`Failed to fetch household members: ${status}`);
  }

  return response.json();
}
```

// Directory: lib\services, File: invitationService.ts
// File Type: ts
```typescript
// src/lib/services/invitationService.ts
import { randomBytes } from 'crypto';
import { generateUUID } from '@/lib/utils';
import { sendInvitationEmail } from '@/lib/email';

// Generate a secure random token
export function generateToken(length: number = 32): string {
  return randomBytes(length).toString('hex');
}

export class ValidationError extends Error {
  status: number;
  
  constructor(message: string, status: number = 400) {
    super(message);
    this.name = 'ValidationError';
    this.status = status;
  }
}

export class ResourceNotFoundError extends Error {
  status: number;
  
  constructor(message: string, status: number = 404) {
    super(message);
    this.name = 'ResourceNotFoundError';
    this.status = status;
  }
}

export class ConflictError extends Error {
  status: number;
  details?: any;
  
  constructor(message: string, details?: any, status: number = 409) {
    super(message);
    this.name = 'ConflictError';
    this.status = status;
    this.details = details;
  }
}

/**
 * Validates invitation request data
 */
export function validateInvitationData(data: any) {
  const { email, householdId, role = 'MEMBER' } = data;
  
  if (!email || !householdId) {
    throw new ValidationError('Missing required fields: email and householdId are required');
  }
  
  // Validate email format
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    throw new ValidationError('Invalid email format');
  }
  
  // Validate role
  const validRoles = ['ADMIN', 'MEMBER', 'GUEST'];
  if (!validRoles.includes(role)) {
    throw new ValidationError('Invalid role. Must be one of: ADMIN, MEMBER, GUEST');
  }
  
  return { email, householdId, role };
}

/**
 * Get invitation by token
 */
export async function getInvitationByToken(supabase: any, token: string) {
  const { data: invitation, error } = await supabase
    .from('Invitation')
    .select(`
      id, 
      email, 
      householdId, 
      role, 
      status, 
      expiresAt,
      createdAt,
      message,
      household:householdId(id, name, address),
      inviter:inviterId(id, name, email, avatar)
    `)
    .eq('token', token)
    .single();
  
  if (error) {
    throw new ResourceNotFoundError('Invalid or expired invitation token');
  }
  
  if (!invitation) {
    throw new ResourceNotFoundError('Invalid or expired invitation token');
  }
  
  return invitation;
}

/**
 * Check if an invitation has expired and update its status if needed
 */
export async function checkInvitationExpiration(supabase: any, invitation: any) {
  const now = new Date();
  const expiry = new Date(invitation.expiresAt);
  
  if (expiry < now) {
    // Auto-update status to EXPIRED
    await supabase
      .from('Invitation')
      .update({ 
        status: 'EXPIRED', 
        updatedAt: now.toISOString()
      })
      .eq('id', invitation.id);
      
    throw new ValidationError('Invitation has expired', 410);
  }
  
  // Check if the invitation has already been used or cancelled
  if (invitation.status !== 'PENDING') {
    throw new ValidationError(`Invitation is no longer valid (status: ${invitation.status})`, 410);
  }
  
  return invitation;
}

/**
 * Check for existing pending invitation
 */
export async function checkExistingInvitation(supabase: any, email: string, householdId: string) {
  const { data: existingInvitation, error } = await supabase
    .from('Invitation')
    .select('id, status')
    .eq('email', email)
    .eq('householdId', householdId)
    .eq('status', 'PENDING')
    .maybeSingle();
  
  if (existingInvitation) {
    throw new ConflictError(
      'An invitation has already been sent to this email for this household',
      { invitationId: existingInvitation.id }
    );
  }
  
  return null;
}

/**
 * Check if user is already a household member
 */
export async function checkExistingMembership(supabase: any, email: string, householdId: string) {
  try {
    const { data: existingUser, error: userError } = await supabase
      .from('User')
      .select('id')
      .eq('email', email)
      .single();
    
    if (existingUser) {
      const { data: householdUser } = await supabase
        .from('HouseholdUser')
        .select('id')
        .eq('userId', existingUser.id)
        .eq('householdId', householdId)
        .maybeSingle();
      
      if (householdUser) {
        throw new ConflictError('This user is already a member of the household');
      }
    }
    
    return null;
  } catch (error) {
    // Only throw if it's a ConflictError; otherwise ignore
    if (error instanceof ConflictError) {
      throw error;
    }
    return null;
  }
}

/**
 * Create a new invitation
 */
export async function createInvitation(
  supabase: any, 
  data: any, 
  userId: string,
  userName: string,
  request: Request
) {
  const { 
    email, 
    householdId, 
    role = 'MEMBER', 
    message = '',
    expirationDays = 7
  } = data;
  
  // Check for existing invitation
  await checkExistingInvitation(supabase, email, householdId);
  
  // Check if user is already a member
  await checkExistingMembership(supabase, email, householdId);
  
  // Generate a unique ID for the invitation
  const inviteId = generateUUID();
  
  // Generate a secure token for the invitation
  const token = generateToken();
  
  // Calculate expiration date
  const now = new Date();
  const expiresAt = new Date(now);
  expiresAt.setDate(now.getDate() + expirationDays);
  
  // Create the invitation record
  const { data: invitation, error: inviteError } = await supabase
    .from('Invitation')
    .insert([
      {
        id: inviteId,
        email,
        householdId,
        inviterId: userId,
        role,
        status: 'PENDING',
        message: message || null,
        token,
        expiresAt: expiresAt.toISOString(),
        createdAt: now.toISOString(),
        updatedAt: now.toISOString()
      }
    ])
    .select('id, email, householdId, role, status, expiresAt, createdAt')
    .single();
  
  if (inviteError) {
    throw new Error('Failed to create invitation');
  }
  
  // Generate invitation link
  const url = new URL(request.url);
  const baseUrl = process.env.NEXT_PUBLIC_APP_URL || `${url.protocol}//${url.host}`;
  const invitationLink = `${baseUrl}/invite?token=${token}`;
  
  // Get household information for the email
  const { data: household } = await supabase
    .from('Household')
    .select('name')
    .eq('id', householdId)
    .single();
  
  // Send invitation email
  try {
    const emailSent = await sendInvitationEmail({
      to: email,
      inviterName: userName,
      householdName: household?.name || 'a household',
      invitationLink,
      role,
      message: message || undefined
    });
    
    return {
      invitation,
      invitationLink,
      message: 'Invitation created successfully',
      emailSent
    };
  } catch (error) {
    // Return success even if email fails
    return {
      invitation,
      invitationLink,
      message: 'Invitation created successfully, but failed to send email notification',
      emailSent: false
    };
  }
}

/**
 * Add a user to a household with a specific role
 */
export async function addUserToHousehold(
    supabase: any,
    userId: string,
    householdId: string,
    role: string
  ) {
    // Check if the user is already a member
    const { data: existingMembership } = await supabase
      .from('HouseholdUser')
      .select('id, role')
      .eq('userId', userId)
      .eq('householdId', householdId)
      .maybeSingle();
    
    if (existingMembership) {
      return {
        message: 'User is already a member of this household',
        role: existingMembership.role,
        householdId
      };
    }
    
    // Add the user to the household
    const membershipId = generateUUID();
    
    const { error: addError } = await supabase
      .from('HouseholdUser')
      .insert([
        {
          id: membershipId,
          userId,
          householdId,
          role,
          joinedAt: new Date().toISOString()
        }
      ]);
    
    if (addError) {
      throw new Error('Failed to add user to the household');
    }
    
    return {
      id: membershipId,
      userId,
      householdId,
      role,
      joinedAt: new Date().toISOString()
    };
  }

/**
 * Update invitation status (accept/decline)
 */
export async function updateInvitationStatus(
  supabase: any,
  invitationId: string,
  status: 'ACCEPTED' | 'DECLINED',
  userEmail: string
) {
  // Get the invitation
  const { data: invitation, error: fetchError } = await supabase
    .from('Invitation')
    .select('*')
    .eq('id', invitationId)
    .single();
  
  if (fetchError || !invitation) {
    throw new ResourceNotFoundError('Invitation not found');
  }
  
  // Check if the user is the recipient
  if (invitation.email !== userEmail) {
    throw new ValidationError('You can only respond to invitations sent to you', 403);
  }
  
  // Check if the invitation is still pending
  if (invitation.status !== 'PENDING') {
    throw new ValidationError('This invitation has already been processed');
  }
  
  // Check if the invitation has expired
  const now = new Date();
  const expiry = new Date(invitation.expiresAt);
  if (expiry < now) {
    throw new ValidationError('This invitation has expired');
  }
  
  // Update the invitation status
  const { data: updatedInvitation, error: updateError } = await supabase
    .from('Invitation')
    .update({ 
      status, 
      updatedAt: new Date().toISOString(),
      respondedAt: new Date().toISOString()
    })
    .eq('id', invitationId)
    .select()
    .single();
  
  if (updateError) {
    throw new Error('Failed to update invitation');
  }
  
  return updatedInvitation;
}

/**
 * Accept invitation by token
 */
export async function acceptInvitationByToken(
  supabase: any,
  token: string,
  user: any,
  claimWithCurrentEmail: boolean = false
) {
  // Find the invitation by token
  const invitation = await getInvitationByToken(supabase, token);
  
  // Check if invitation is valid and not expired
  await checkInvitationExpiration(supabase, invitation);
  
  // Check if the user's email matches the invitation email
  const userEmail = user.email || '';
  if (invitation.email.toLowerCase() !== userEmail.toLowerCase() && !claimWithCurrentEmail) {
    throw new ValidationError(
      'This invitation was sent to a different email address',
      403
    );
  }
  
  // Find or create user record
  const { data: existingUser, error: userError } = await supabase
    .from('User')
    .select('id')
    .eq('email', userEmail)
    .single();
    
  let userDbId;
  if (userError || !existingUser) {
    // Create a new user if not found
    const { data: newUser, error: createError } = await supabase
      .from('User')
      .insert([
        {
          id: user.id,
          email: userEmail,
          name: user.name || userEmail?.split('@')[0] || 'User',
          password: 'MANAGED_BY_SUPABASE_AUTH',
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString()
        }
      ])
      .select('id')
      .single();
      
    if (createError || !newUser) {
      throw new Error('Failed to create user record');
    }
    
    userDbId = newUser.id;
  } else {
    userDbId = existingUser.id;
  }
  
  // Try to get any existing household membership
  const { data: existingMembership } = await supabase
    .from('HouseholdUser')
    .select('id, role')
    .eq('userId', userDbId)
    .eq('householdId', invitation.householdId)
    .maybeSingle();
  
  const now = new Date();
  
  if (existingMembership) {
    // Update the invitation status to ACCEPTED since we're effectively accepting it
    await supabase
      .from('Invitation')
      .update({ 
        status: 'ACCEPTED', 
        updatedAt: now.toISOString(),
        respondedAt: now.toISOString(),
        notes: claimWithCurrentEmail ? `Claimed by ${userEmail} (original recipient: ${invitation.email})` : undefined
      })
      .eq('id', invitation.id);
    
    return { 
      message: 'You are already a member of this household',
      role: existingMembership.role,
      householdId: invitation.householdId,
      redirectTo: `/dashboard/${invitation.householdId}`
    };
  }
  
  // Accept the invitation by updating status
  await supabase
    .from('Invitation')
    .update({ 
      status: 'ACCEPTED', 
      updatedAt: now.toISOString(),
      respondedAt: now.toISOString(),
      notes: claimWithCurrentEmail ? `Claimed by ${userEmail} (original recipient: ${invitation.email})` : undefined
    })
    .eq('id', invitation.id);
  
  // Add the user to the household
  const membershipId = generateUUID();
  
  const { error: addError } = await supabase
    .from('HouseholdUser')
    .insert([
      {
        id: membershipId,
        userId: userDbId,
        householdId: invitation.householdId,
        role: invitation.role,
        joinedAt: now.toISOString()
      }
    ]);
  
  if (addError) {
    throw new Error('Failed to add you to the household');
  }
  
  // Get household details to include in response
  const { data: household } = await supabase
    .from('Household')
    .select('name')
    .eq('id', invitation.householdId)
    .single();
  
  return {
    message: 'You have successfully joined the household',
    householdId: invitation.householdId,
    householdName: household?.name || 'Household',
    role: invitation.role,
    joinedAt: now.toISOString(),
    redirectTo: `/dashboard/${invitation.householdId}`
  };
}
```

// Directory: lib\validation, File: invitationValidation.ts
// File Type: ts
```typescript
// Create a shared validation utility
// src/lib/validation/invitationValidation.ts
export function validateEmail(email: string): boolean {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }
  
  export function validateInvitationForm(data: {
    email: string,
    role: string,
    message?: string
  }): {valid: boolean, error?: string} {
    if (!data.email) {
      return {valid: false, error: 'Email is required'};
    }
    
    if (!validateEmail(data.email)) {
      return {valid: false, error: 'Please enter a valid email address'};
    }
    
    return {valid: true};
  }
```

